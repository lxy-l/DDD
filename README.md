# Domain Driven Design 理解
>对于领域驱动设计思想的学习与理解。

---

## 战略设计

---
## 战术设计






---


## 分层
### Application 应用层   
>ApplicationService应该永远返回DTO而不是Entity
>		1.构建领域边界
>		2.降低规则依赖
>		3.通过DTO组合降低成本
   1. 用来封装业务逻辑
   2. 面向用例。
   3. 粗粒度。
    4. 外部视图看系统。
    5. 一个请求对应一个方法。
    6. 服务之间不相互调用。
    7. 职责一般包括：跨模块协调、DTO转换、事务AOP、权限AOP、日志AOP、异常AOP、邮件、消息队列。
    8. 组合多个业务实体、基础设施层的各种组件完成业务服务
    Service：
    9. 获取输入。
    10. 发送消息给领域服务，要求执行
    11. 监听确认消息
    12. 决定使用基础设施层Service来发送通知


### Domain 领域层
>DDD概念中的核心业务层，封装所有业务逻辑，包含entity、value object、domain service、domain event等。

1. Entity(Reference Object):由标识定义的实体。
2. Value Object：描述了一个事务的某种特征。用于描述领域的某个方面而本身没有概念标识的对象（值对象）实例化之后表现一些设计元素，对于这些元素，只关心他是什么，而不关心他是谁。当我们关心一个模型的属性时，应把他归类为Value Object。他是不可变得，不需要任何标识
3. Aggregate Root: 聚合是用来封装真正的不变性，而不是简单的将对象组合在一起；
				聚合应尽量设计的小；
				聚合之间的关联通过ID，而不是对象引用；
				聚合内强一致性，聚合之间最终一致性；
4. DomainService:领域层中的服务，负责检查是否满足临界值。例如银行转账功能。应属于领域服务，因为它包含重要业务逻辑。
		1.与必要的账户和总账对象进行交互，执行相应的借入贷出操作
		2.提供结果确认（允许或拒绝）

1.聚合根、实体、值对象的区别？

	从标识的角度：

	聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法；

	从是否只读的角度：

	聚合根除了唯一标识外，其他所有状态信息都理论上可变；实体是可变的；值对象是只读的；

	从生命周期的角度：

	聚合根有独立的生命周期，实体的生命周期从属于其所属的聚合，实体完全由其所属的聚合根负责管理维护；值对象无生命周期可言，因为只是一个值；

2.聚合根、实体、值对象对象之间如何建立关联？

	聚合根到聚合根：通过ID关联；

	聚合根到其内部的实体，直接对象引用；

	聚合根到值对象，直接对象引用；

	实体对其他对象的引用规则：1）能引用其所属聚合内的聚合根、实体、值对象；2）能引用外部聚合根，但推荐以ID的方式关联，另外也可以关联某个外部聚合内的实体，但必须是ID关联，否则就出现同一个实体的引用被两个聚合根持有，这是不允许的，一个实体的引用只能被其所属的聚合根持有；

	值对象对其他对象的引用规则：只需确保值对象是只读的即可，推荐值对象的所有属性都尽量是值对象；

3.如何识别聚合与聚合根？

	明确含义：一个Bounded Context（界定的上下文）可能包含多个聚合，每个聚合都有一个根实体，叫做聚合根；

	识别顺序：先找出哪些实体可能是聚合根，再逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象；最后再划分Bounded Context；

	聚合边界确定法则：根据不变性约束规则（Invariant）。不变性规则有两类：1）聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合；2）聚合内的某些对象的状态必须满足某个业务规则；

### Infrastructure 基础设施层
>提供公共组件，如：Logging、Trascation、HttpClient等。



### WebApi 展现层
>对外提供各种协议形式的服务，并提供Validation参数校验，authenticate权限认证，业务实体组装器Assembler等。




---
# 总结
 1.领域模型由领域专家和开发人员交流建模

 2.应该领域层调用应用层。认为领域层是被驱动调用的，还是静态数据驱动思维。