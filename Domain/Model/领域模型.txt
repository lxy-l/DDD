Entity(Reference Object):由标识定义的实体。

Value Object：描述了一个事务的某种特征。用于描述领域的某个方面而本身没有概念标识的对象（值对象）实例化之后表现一些设计元素，对于这些元素，只关心他是什么，而不关心他是谁。当我们关心一个模型的属性时，应把他归类为Value Object。他是不可变得，不需要任何标识

Aggregate Root: 聚合是用来封装真正的不变性，而不是简单的将对象组合在一起；
				聚合应尽量设计的小；
				聚合之间的关联通过ID，而不是对象引用；
				聚合内强一致性，聚合之间最终一致性；

1.聚合根、实体、值对象的区别？

	从标识的角度：

	聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识，不存在这个值对象或那个值对象的说法；

	从是否只读的角度：

	聚合根除了唯一标识外，其他所有状态信息都理论上可变；实体是可变的；值对象是只读的；

	从生命周期的角度：

	聚合根有独立的生命周期，实体的生命周期从属于其所属的聚合，实体完全由其所属的聚合根负责管理维护；值对象无生命周期可言，因为只是一个值；

2.聚合根、实体、值对象对象之间如何建立关联？

	聚合根到聚合根：通过ID关联；

	聚合根到其内部的实体，直接对象引用；

	聚合根到值对象，直接对象引用；

	实体对其他对象的引用规则：1）能引用其所属聚合内的聚合根、实体、值对象；2）能引用外部聚合根，但推荐以ID的方式关联，另外也可以关联某个外部聚合内的实体，但必须是ID关联，否则就出现同一个实体的引用被两个聚合根持有，这是不允许的，一个实体的引用只能被其所属的聚合根持有；

	值对象对其他对象的引用规则：只需确保值对象是只读的即可，推荐值对象的所有属性都尽量是值对象；

3.如何识别聚合与聚合根？

	明确含义：一个Bounded Context（界定的上下文）可能包含多个聚合，每个聚合都有一个根实体，叫做聚合根；

	识别顺序：先找出哪些实体可能是聚合根，再逐个分析每个聚合根的边界，即该聚合根应该聚合哪些实体或值对象；最后再划分Bounded Context；

	聚合边界确定法则：根据不变性约束规则（Invariant）。不变性规则有两类：1）聚合边界内必须具有哪些信息，如果没有这些信息就不能称为一个有效的聚合；2）聚合内的某些对象的状态必须满足某个业务规则；